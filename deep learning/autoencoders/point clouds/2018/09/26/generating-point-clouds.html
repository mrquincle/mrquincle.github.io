<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Generating Point Clouds | Robots, machine learning, global issues</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Generating Point Clouds" />
<meta name="author" content="Anne van Rossum" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Points in a 3D space can be generated by auto-encoders. In this way the deep network learns representations that are intrinsic to point clouds." />
<meta property="og:description" content="Points in a 3D space can be generated by auto-encoders. In this way the deep network learns representations that are intrinsic to point clouds." />
<link rel="canonical" href="https://annevanrossum.com/deep%20learning/autoencoders/point%20clouds/2018/09/26/generating-point-clouds.html" />
<meta property="og:url" content="https://annevanrossum.com/deep%20learning/autoencoders/point%20clouds/2018/09/26/generating-point-clouds.html" />
<meta property="og:site_name" content="Robots, machine learning, global issues" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-26T08:15:22+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Generating Point Clouds" />
<script type="application/ld+json">
{"description":"Points in a 3D space can be generated by auto-encoders. In this way the deep network learns representations that are intrinsic to point clouds.","@type":"BlogPosting","headline":"Generating Point Clouds","dateModified":"2018-09-26T08:15:22+00:00","datePublished":"2018-09-26T08:15:22+00:00","url":"https://annevanrossum.com/deep%20learning/autoencoders/point%20clouds/2018/09/26/generating-point-clouds.html","author":{"@type":"Person","name":"Anne van Rossum"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://annevanrossum.com/deep%20learning/autoencoders/point%20clouds/2018/09/26/generating-point-clouds.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://annevanrossum.com/feed.xml" title="Robots, machine learning, global issues" />

  
  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
  <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
          ]}
        );
      });
    </script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Robots, machine learning, global issues</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Generating Point Clouds</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-09-26T08:15:22+00:00" itemprop="datePublished">Sep 26, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>If we do want robots to learn about the world, we can use computer vision. We can employ traditional methods. Build up a full-fledged model from corner detectors, edge detectors, feature descriptors, gradient descriptors, etc. We can also use modern deep learning techniques. One large neural network hopefully captures similarly or even better abstractions compared to the conventional computer vision pipeline.</p>

<p>Computer vision is not the only choice though! In recent years there is a proliferation of a different type of data: depth data. Collections (or clouds) of points represent 3D shapes. In a game setting the Kinect was a world-shocking invention using structured light. In robotics and autonomous cars LIDARs are used. There is huge debate about which sensors are gonna “win”, but I personally doubt there will be a clearcut winner. My line of reasoning:</p>

<ul>
  <li>Humans use vision and have perfected this in many ways. It would be silly to not use cameras.</li>
  <li>Depth sensors can provide information when vision gets obstructed.</li>
  <li>Humans use glasses, microscopes, infrared goggles, all to enhance our senses. We are basically cyborgs.</li>
  <li>Robots will benefit from a rich sensory experience just like we do. They want to be cyborgs too.</li>
</ul>

<!--more-->

<h1 id="point-clouds">Point clouds</h1>

<p>Point clouds are quite a good description. Objects are represented by individual points in a 3D space. By making the points a bit bigger you can easily figure out the shapes yourself (see the figure below).</p>

<p><img src="/images/blog/dfaust_dataset.png" alt="The D-FAUST dataset and interpolation between the figure totally at the left and the one totally at the right. Copyright: Achlioptas et al. (2018)." title="Interpolation between two distinct human figures shows a gradual transition from one figure to the next" /></p>

<p>A group of researchers who started to study point clouds are 
<a href="http://web.stanford.edu/~optas/">Panos Achlioptas</a>,
<a href="https://geometry.stanford.edu/person.php?id=diamanti">Olga Diamanti</a>,
<a href="http://mitliagkas.github.io/">Ioannis Mitliagkas</a>, and
<a href="https://geometry.stanford.edu/member/guibas/">Leonidas Guibas</a> in the paper <a href="https://arxiv.org/pdf/1707.02392.pdf">Learning Representations and Generative Models for 3D Point Clouds</a> from Leonidas Guibas’ Geometric Computation group in the Computer Science Department of Stanford University. Side note: prof. Guibas obtained his PhD under the supervision of Donald Knuth. You can reach Panos via <a href="http://web.stanford.edu/~optas/contact.html">his website</a>. I haven’t found his Twitter account.</p>

<p>There are two main reasons why point clouds should be treated different from pixels in a neural network:</p>

<ol>
  <li>The convolution operator works on a grid. Encoding 3D data on a grid would encode a lot of empty voxels. This means that for point clouds we cannot just convolution.</li>
  <li>Point clouds are permutation invariant. Only the 3D position of a point matters, their id does not. Points in a point cloud can be numbered in any way. It still describes the same object. A comparison operator between two point clouds need to take this into account. Preferably the latent variables will also be permutation invariant.</li>
</ol>

<h2 id="permutation-invariant-distance-metrics">Permutation invariant distance metrics</h2>

<p>There are permutation invariant distance metrics available. The authors describe the <a href="https://en.wikipedia.org/wiki/Earth_mover%27s_distance">Earth Mover’s Distance (EM)</a>. This is a concept discovered by Gaspard Monge in 1781 on how to transport soil from one place to the next with minimal effort. Let us define the flow \(f_{i,j}\) between location \(i\) and \(j\) with distance \(d_{i,j}\), then the EM distance between location \(i \in P\) and \(j \in Q\) is as follows:</p>

\[d_{EM}(P,Q) = \frac{ \sum_{i=1}^m \sum_{j=1}^n f_{i,j} d_{i,j} }{ \sum_{i=1}^m \sum_{j=1}^n f_{i,j} }\]

<p>The individual flow is multiplied with the corresponding distance. The overall sum is normalized with the overall flow. In mathematics this is known as the Wasserstein metric. <a href="https://vincentherrmann.github.io/blog/wasserstein/">This blog post</a> introduces the Wasserstein metric perfectly and <a href="https://www.alexirpan.com/2017/02/22/wasserstein-gan.html">this blog post</a> explains its relevance to Generative Adversarial Networks.</p>

<p>The Wasserstein metric is differentiable almost everywhere. <a href="https://en.wikipedia.org/wiki/Almost_everywhere">Almost everywhere (a.e.)</a> is a technical term related to a set having measure zero. It states that the elements for which the property (in this case being differentiable) is not valid has measure zero. Another example of a function that is differentiable a.e. is a monotonic function on \([a,b] \rightarrow \mathbb{R}\).</p>

<p>The Chamfer pseudo-distance (C) measure is another measure which calculates the squared distance between each point in one set to the nearest neighbour in the other set:</p>

\[d_{C}(P,Q) = \sum_{i=1}^m \min_j d_{i,j}^2 + \sum_{j=1}^n \min_i d_{i,j}^2\]

<p>It’s stated that \(d_{C}\) is more efficient to compute than \(d_{EM}\).</p>

<p>Immediately we can observe from these metrics that they are not invariant with respect to rotations, translations, or scaling.</p>

<h2 id="comparison-metrics">Comparison metrics</h2>

<p>To compare shapes in a 3D space we can follow different strategies. We describe three methods that take the spatial
nature into account and that compare over sets of 3D objects (so we can compare set \(P\) with set \(Q\)):</p>

<ol>
  <li>Jensen-Shannon divergence.</li>
  <li>Coverage</li>
  <li>Minimum Matching distance.</li>
</ol>

<h3 id="jensen-shannon">Jensen-Shannon</h3>

<p>First of all, we can align the point cloud data along the axis, introduce voxels and measure the number of points in
each corresponding voxel. Then we use a distance metric using these quantities, in this case a Jensen-Shannon divergence.</p>

\[d_{JS}(P||Q) = \frac{1}{2} D_{KL}(P||M) + \frac{1}{2} D_{KL}(Q||M)\]

<p>Here \(M = \frac{1}{2}(P + Q)\) and \(D_{KL}\) is the Kullbach-Leibler divergence metric.</p>

<p>To compare sets of point clouds we can do exactly the same. In this case the number of points in each voxel is just the
collection of points across all point clouds in that set.</p>

<h3 id="coverage">Coverage</h3>

<p>Coverage is defined by the fraction of point clouds in \(P\) that are matched with point clouds in \(Q\). The match is
defined by one the permutation invariant distance metrics. It’s not entirely clear how this is completely specified 
to me. Is there a threshold used that defines if it is a match? Or is it just a sum or average?</p>

<h3 id="minimum-matching-distance">Minimum Matching distance</h3>

<p>The minimum matching distance measures also the fidelity of \(P\) versus \(Q\) (compared to the coverage metric). This
indeed uses an average over the (permutation invariant) distances between point clouds.</p>

<h2 id="generation">Generation</h2>

<p>The pipeline followed by the authors is similar to that of PointNet. The pointcloud contains 2048 3D points. 
This data is fed into the encoder. The encoder exists of 1D convolutional layers (five of them) with a kernel size of 1 each of which are followed by a layer with ReLUs and one to
perform batch normalization. After this pipeline an permutation-invariant max layer is placed. To read more on a
1D convolutional layer check the following clip by Andrew Ng. On just a 2D matrix a 1D convolutional layer would be
just a multiplication by a factor. However, on 3D objects, it can be used to reduce layers or introduce a 
nonlinearity.</p>

<iframe width="740" height="480" src="//www.youtube.com/embed/vcp0XvDAX68" frameborder="0" allowfullscreen=""></iframe>

<p>The decoder contains three layers, the first two followed by ReLUs.</p>

<h2 id="results">Results</h2>

<p>Some of the results from this work:</p>

<ul>
  <li>The GAN operating on the raw data converges much slower than the GAN operating on the the latent variables.</li>
  <li>The latent GAN model using the AE with Earth Mover’s distance outperforms the one with the Chamfer pseudo distance.</li>
  <li>Both latent GAN models suffer from mode collapse. Wasserstein GAN does not…</li>
</ul>

<p>Note that the Wasserstein metric is the same as the Earth Mover’s distance. So the above basically states that using
Wasserstein distance makes sense for both the autoencoder as well as the GAN involved.</p>

<p>There are not yet many models that operate directly on point clouds. PointNet is one of the most famous ones.
In a ModelNet40 shape classification task it has the following performance:</p>

<ul>
  <li>87.2% - Vanilla PointNet, without transformation networks</li>
  <li>89.2% - PointNet, with transformation networks</li>
  <li>90.7% - PointNet++, with multi-resolution grouping to cope with non-uniform sampling densities</li>
  <li>91.9% - PointNet++, with face normals as additional point features</li>
</ul>

<p>And the paper’s performance:</p>

<ul>
  <li>84.0% - Earth Mover’s distance</li>
  <li>84.5% - Chamfer distance</li>
</ul>

<p>It is not clear to me why they don’t list the results of the PointNet and PointNet++ papers which they both cite.
They should have definitely told why it cannot be compared if they think that’s the case.</p>

<h2 id="promising-research-direction">Promising research direction</h2>

<p>One of the most obvious improvements seem to be the choice of the Wasserstein metric in different parts of the
architecture. Another paper that caught my interest is <a href="https://openreview.net/pdf?id=B1xsqj09Fm">Large Scale GAN Training for High Fidelity Natural Image Synthesis (pdf)</a>
under review at ICLR 2019.</p>

<p>An interesting aspect of this paper is that they sample from a different distribution while testing versus while training.
They introduce a “truncation trick”. It samples from a truncated Normal distribution rather than \(N(0,\sigma)\) for the latent variables. (The values above a particular threshold are just sampled again until they are below that threshold.) I don’t completely get this. What’s going on there? Is there a mode in the network that defines the prototypical dog and are other dogs defined by nonzero values in the latent variable space? Then this seem to show that the layer exhibits an non-intuitive decomposition of the task at hand. I would expect a zero vector to correspond to an “abstract dog” and have all nonzero parameters contribute in an attribute like fashion. This seems to be more prototype-like, similar to old-fashioned vector quantization.</p>

<p>They however also define other latent random variables (in appendix E). The censored normal \(\max[N(0,\sigma),0]\) is interesting. It reminds me of <a href="https://yliapis.github.io/Non-Negative-Matrix-Factorization/">nonnegative matrix factorization</a>. By using a nonnegative constraint the representation becomes additive (part-based) and sparse. That’s quite different from prototype-like methods.</p>

<p>In the last few months I’ve been trying nonparametric extensions to the latent layer, but these experiments do not seem to be 
very promising.</p>

<p>A promising research direction might be to study autoencoders where the latent variables are such that they exhibit the 
same <strong>nonnegative</strong> (part-based representation) features. When we have a latent layer that decomposes the input like this,
it might become more valuable to subsequently have a nonparametric extension.</p>


  </div><a class="u-url" href="/deep%20learning/autoencoders/point%20clouds/2018/09/26/generating-point-clouds.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Robots, machine learning, global issues</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Anne van Rossum</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/mrquincle"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mrquincle</span></a></li><li><a href="https://www.twitter.com/annevanrossum"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">annevanrossum</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A blog about robots, machine learning, and other random stuff</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
